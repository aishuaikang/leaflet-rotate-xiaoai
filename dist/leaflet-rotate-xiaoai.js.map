{"version":3,"file":"leaflet-rotate-xiaoai.js","sources":["../src/dom/DomUtil.js","../src/dom/Draggable.js","../src/geometry/Point.js","../src/layer/DivOverlay.js","../src/layer/Popup.js","../src/layer/Tooltip.js","../src/layer/marker/Icon.js","../src/layer/marker/Marker.js","../src/layer/tile/GridLayer.js","../src/layer/vector/Renderer.js","../src/map/Map.js","../src/map/handler/ContainerMutation.js","../src/control/Rotate.js"],"sourcesContent":["/**\n * @external L.DomUtil\n *\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/dom/DomUtil.js\n */\n\nconst domUtilProto = L.extend({}, L.DomUtil);\n\nL.extend(L.DomUtil, {\n    /**\n     * Resets the 3D CSS transform of `el` so it is\n     * translated by `offset` pixels and optionally\n     * scaled by `scale`. Does not have an effect if\n     * the browser doesn't support 3D CSS transforms.\n     *\n     * @param {HTMLElement} el\n     * @param {L.Point} offset\n     * @param {Number} scale\n     * @param {Number} bearing\n     * @param {L.Point} pivot\n     */\n    setTransform: function (el, offset, scale, bearing, pivot) {\n        console.log(\"setTransform\", { el, offset, scale, bearing, pivot });\n        var pos = offset || new L.Point(0, 0);\n\n        if (!bearing) {\n            offset = pos._round();\n            return domUtilProto.setTransform.apply(this, arguments);\n        }\n\n        pos = pos.rotateFrom(bearing, pivot);\n\n        el.style[L.DomUtil.TRANSFORM] =\n            \"translate3d(\" +\n            pos.x +\n            \"px,\" +\n            pos.y +\n            \"px\" +\n            \",0)\" +\n            (scale ? \" scale(\" + scale + \")\" : \"\") +\n            \" rotate(\" +\n            bearing +\n            \"rad)\";\n    },\n\n    /**\n     * Sets the position of `el` to coordinates specified by\n     * `position`, using CSS translate or top/left positioning\n     * depending on the browser (used by Leaflet internally\n     * to position its layers).\n     *\n     * @param {HTMLElement} el\n     * @param {L.Point} point\n     * @param {Number} bearing\n     * @param {L.Point} pivot\n     * @param {Number} scale\n     */\n    // setPosition: function (el, point, bearing, pivot, scale) {\n    //     console.log(\"setPosition\", { el, point, bearing, pivot, scale });\n    //     if (!bearing) {\n    //         return domUtilProto.setPosition.apply(this, arguments);\n    //     }\n\n    //     /*eslint-disable */\n    //     el._leaflet_pos = point;\n    //     /*eslint-enable */\n\n    //     if (L.Browser.any3d) {\n    //         L.DomUtil.setTransform(el, point, scale, bearing, pivot);\n    //     } else {\n    //         el.style.left = point.x + \"px\";\n    //         el.style.top = point.y + \"px\";\n    //     }\n    // },\n\n    /**\n     * @constant radians = degrees × π/180°\n     */\n    DEG_TO_RAD: Math.PI / 180,\n\n    /**\n     * @constant degrees = radians × 180°/π\n     */\n    RAD_TO_DEG: 180 / Math.PI,\n});\n","/**\n * @external L.Draggable\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/dom/Draggable.js\n */\n\n/**\n * A class for making DOM elements draggable (including touch support).\n * Used internally for map and marker dragging. Only works for elements\n * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\n */\n\nL.Draggable.include({\n\n    /** @TODO */\n    // updateMapBearing: function(mapBearing) {\n    //     this._mapBearing = mapBearing;\n    // },\n\n});","/**\n * @external L.Point\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/geometry/Point.js\n */\n\nL.extend(L.Point.prototype, {\n\n    /**\n     * Rotate around (0,0) by applying the 2D rotation matrix:\n     * \n     * ⎡ x' ⎤ = ⎡ cos θ  -sin θ ⎤ ⎡ x ⎤\n     * ⎣ y' ⎦   ⎣ sin θ   cos θ ⎦ ⎣ y ⎦\n     * \n     * @param theta must be given in radians.\n     */\n    rotate: function(theta) {\n        return this.rotateFrom(theta, new L.Point(0,0))\n    },\n\n    /**\n     * Rotate around (pivot.x, pivot.y) by:\n     * \n     * 1. subtract (pivot.x, pivot.y)\n     * 2. rotate around (0, 0)\n     * 3. add (pivot.x, pivot.y) back\n     * \n     * same as `this.subtract(pivot).rotate(theta).add(pivot)`\n     * \n     * @param {Number} theta \n     * @param {L.Point} pivot \n     * \n     * @returns {L.Point}\n     */\n    rotateFrom: function(theta, pivot) {\n        if (!theta) { return this; }\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta);\n        var cx = pivot.x,\n            cy = pivot.y;\n        var x = this.x - cx,\n            y = this.y - cy;\n\n        return new L.Point(\n            x * cosTheta - y * sinTheta + cx,\n            x * sinTheta + y * cosTheta + cy\n        );\n    },\n\n});\n","/**\n * @external L.DivOverlay\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/DivOverlay.js\n */\n\nconst divOverlayProto = L.extend({}, L.DivOverlay.prototype);\n\nL.DivOverlay.include({\n\n    /**\n     * Update L.Popup and L.Tooltip anchor positions after\n     * the map is moved by calling `map.setBearing(theta)`\n     * \n     * @listens L.Map~rotate\n     */\n    getEvents: function() {\n        return L.extend(divOverlayProto.getEvents.apply(this, arguments), { rotate: this._updatePosition });\n    },\n\n    /**\n     * 0. update element anchor point (divOverlayProto v1.9.3)\n     * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)\n     */\n    _updatePosition: function() {\n        if (!this._map) { return; }\n        divOverlayProto._updatePosition.apply(this, arguments);\n        if (this._map && this._map._rotate && this._zoomAnimated) {\n            var anchor = this._getAnchor();\n            var pos = L.DomUtil.getPosition(this._container).subtract(anchor);\n            L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(pos).add(anchor));\n        }\n\n    },\n\n});\n","/**\n * @external L.Popup\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/Popup.js\n */\n\nconst popupProto = L.extend({}, L.Popup.prototype);\n\nL.Popup.include({\n\n    /**\n     * 0. update element anchor point (popupProto v1.9.3)\n     * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)\n     */\n    _animateZoom: function(e) {\n        popupProto._animateZoom.apply(this, arguments);\n        if (this._map && this._map._rotate) {\n            var anchor = this._getAnchor();\n            var pos = L.DomUtil.getPosition(this._container).subtract(anchor);\n            L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(pos).add(anchor));\n        }\n    },\n\n    /**\n     * Fix for L.popup({ keepInView = true })\n     * \n     * @see https://github.com/fnicollet/Leaflet/pull/21\n     */\n    _adjustPan: function() {\n        if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }\n\n        // We can endlessly recurse if keepInView is set and the view resets.\n        // Let's guard against that by exiting early if we're responding to our own autopan.\n        if (this._autopanning) {\n            this._autopanning = false;\n            return;\n        }\n\n        var map = this._map,\n            marginBottom = parseInt(L.DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,\n            containerHeight = this._container.offsetHeight + marginBottom,\n            containerWidth = this._containerWidth,\n            layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\n\n        layerPos._add(L.DomUtil.getPosition(this._container));\n\n        /** @TODO use popupProto._adjustPan */\n        // var containerPos = map.layerPointToContainerPoint(layerPos);\n        var containerPos = layerPos._add(this._map._getMapPanePos()),\n            padding = L.point(this.options.autoPanPadding),\n            paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\n            paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\n            size = map.getSize(),\n            dx = 0,\n            dy = 0;\n\n        if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\n            dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n        }\n        if (containerPos.x - dx - paddingTL.x < 0) { // left\n            dx = containerPos.x - paddingTL.x;\n        }\n        if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\n            dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n        }\n        if (containerPos.y - dy - paddingTL.y < 0) { // top\n            dy = containerPos.y - paddingTL.y;\n        }\n\n        // @namespace Map\n        // @section Popup events\n        // @event autopanstart: Event\n        // Fired when the map starts autopanning when opening a popup.\n        if (dx || dy) {\n            // Track that we're autopanning, as this function will be re-ran on moveend\n            if (this.options.keepInView) {\n                this._autopanning = true;\n            }\n            map\n                .fire('autopanstart')\n                .panBy([dx, dy]);\n        }\n    },\n\n});\n","/**\n * @external L.Tooltip\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/Tooltip.js\n */\n\nconst tooltipProto = L.extend({}, L.Tooltip.prototype);\n\nL.Tooltip.include({\n\n    _animateZoom: function(e) {\n        if (!this._map._rotate) {\n            return tooltipProto._animateZoom.apply(this, arguments);\n        }\n        var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n\n        pos = this._map.rotatedPointToMapPanePoint(pos);\n        this._setPosition(pos);\n    },\n\n    _updatePosition: function() {\n        if (!this._map._rotate) {\n            return tooltipProto._updatePosition.apply(this, arguments);\n        }\n        var pos = this._map.latLngToLayerPoint(this._latlng);\n\n        pos = this._map.rotatedPointToMapPanePoint(pos);\n        this._setPosition(pos);\n    },\n\n});\n","/**\n * @external L.Icon\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/marker/Icon.js\n */\n\nconst iconProto = L.extend({}, L.Icon.prototype);\n\nL.Icon.include({\n\n    _setIconStyles: function(img, name) {\n        var options = this.options;\n        var sizeOption = options[name + 'Size'];\n\n        if (typeof sizeOption === 'number') {\n            sizeOption = [sizeOption, sizeOption];\n        }\n\n        var size = L.point(sizeOption),\n            anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||\n                size && size.divideBy(2, true));\n\n        img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n\n        if (anchor) {\n            img.style.marginLeft = (-anchor.x) + 'px';\n            img.style.marginTop = (-anchor.y) + 'px';\n            /** @TODO use iconProto._setIconStyles */\n            img.style[L.DomUtil.TRANSFORM + \"Origin\"] = anchor.x + \"px \" + anchor.y + \"px 0px\";\n        }\n\n        if (size) {\n            img.style.width = size.x + 'px';\n            img.style.height = size.y + 'px';\n        }\n    },\n\n});\n","/**\n * @external L.Marker\n * @external L.Handler.MarkerDrag\n *\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/marker/Marker.js\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/marker/Marker.Drag.js\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/dom/Draggable.js\n */\n\nconst markerProto = L.extend({}, L.Marker.prototype);\n\nL.Marker.mergeOptions({\n    /**\n     * Rotation of this marker in rad\n     *\n     * @type {Number}\n     */\n    rotation: 0,\n\n    /**\n     * Rotate this marker when map rotates\n     *\n     * @type {Boolean}\n     */\n    rotateWithView: false,\n\n    /**\n     * Scale of the marker icon\n     *\n     * @type {Number}\n     */\n    scale: undefined,\n});\n\nvar markerDragProto; // retrived at runtime (see below: L.Marker::_initInteraction())\n\nvar MarkerDrag = {\n    // _onDragStart: function() {\n    //     if (!this._marker._map._rotate) {\n    //         return markerDragProto._onDragStart.apply(this, arguments);\n    //     }\n    //     this._draggable.updateMapBearing(this._marker._map._bearing);\n    // },\n\n    _onDrag: function (e) {\n        var marker = this._marker,\n            /** @TODO use markerDragProto._onDrag */\n            rotated_marker =\n                marker.options.rotation || marker.options.rotateWithView,\n            shadow = marker._shadow,\n            iconPos = L.DomUtil.getPosition(marker._icon);\n\n        /** @TODO use markerDragProto._onDrag */\n        // update shadow position\n        if (!rotated_marker && shadow) {\n            L.DomUtil.setPosition(shadow, iconPos);\n        }\n\n        /** @TODO use markerDragProto._onDrag */\n        if (marker._map._rotate) {\n            // Reverse calculation from mapPane coordinates to rotatePane coordinates\n            iconPos = marker._map.mapPanePointToRotatedPoint(iconPos);\n        }\n        var latlng = marker._map.layerPointToLatLng(iconPos);\n\n        marker._latlng = latlng;\n        e.latlng = latlng;\n        e.oldLatLng = this._oldLatLng;\n\n        /** @TODO use markerDragProto._onDrag */\n        if (rotated_marker)\n            marker.setLatLng(\n                latlng\n            ); // use `setLatLng` to presisit rotation. low efficiency\n        else marker.fire(\"move\", e); // `setLatLng` will trig 'move' event. we imitate here.\n\n        // @event drag: Event\n        // Fired repeatedly while the user drags the marker.\n        marker.fire(\"drag\", e);\n    },\n\n    _onDragEnd: function (e) {\n        if (this._marker._map._rotate) {\n            this._marker.update();\n        }\n        markerDragProto._onDragEnd.apply(this, arguments);\n    },\n};\n\nL.Marker.include({\n    /**\n     * Update L.Marker anchor position after the map\n     * is moved by calling `map.setBearing(theta)`\n     *\n     * @listens L.Map~rotate\n     */\n    getEvents: function () {\n        return L.extend(markerProto.getEvents.apply(this, arguments), {\n            rotate: this.update,\n        });\n    },\n\n    _initInteraction: function () {\n        var ret = markerProto._initInteraction.apply(this, arguments);\n        if (\n            this.dragging &&\n            this.dragging.enabled() &&\n            this._map &&\n            this._map._rotate\n        ) {\n            // L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable\n            markerDragProto =\n                markerDragProto || Object.getPrototypeOf(this.dragging);\n            this.dragging.disable();\n            Object.assign(this.dragging, {\n                // _onDragStart: MarkerDrag._onDragStart.bind(this.dragging),\n                _onDrag: MarkerDrag._onDrag.bind(this.dragging),\n                _onDragEnd: MarkerDrag._onDragEnd.bind(this.dragging),\n            });\n            this.dragging.enable();\n        }\n        return ret;\n    },\n\n    _setPos: function (pos) {\n        /** @TODO use markerProto._setPos */\n        if (this._map._rotate) {\n            pos = this._map.rotatedPointToMapPanePoint(pos);\n        }\n\n        /** @TODO use markerProto._setPos */\n        var bearing = this.options.rotation || 0;\n        if (this.options.rotateWithView) {\n            bearing += this._map._bearing;\n        }\n\n        /** @TODO use markerProto._setPos */\n        if (this._icon) {\n            L.DomUtil.setPosition(\n                this._icon,\n                pos,\n                bearing,\n                pos,\n                this.options.scale\n            );\n        }\n\n        /** @TODO use markerProto._setPos */\n        if (this._shadow) {\n            L.DomUtil.setPosition(\n                this._shadow,\n                pos,\n                bearing,\n                pos,\n                this.options.scale\n            );\n        }\n\n        this._zIndex = pos.y + this.options.zIndexOffset;\n\n        this._resetZIndex();\n    },\n\n    // _updateZIndex: function(offset) {\n    //     if (!this._map._rotate) {\n    //         return markerProto._updateZIndex.apply(this, arguments);\n    //     }\n    //     this._icon.style.zIndex = Math.round(this._zIndex + offset);\n    // },\n\n    setRotation: function (rotation) {\n        this.options.rotation = rotation;\n        this.update();\n    },\n});\n","/**\n * @external L.GridLayer\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/tile/GridLayer.js\n */\n\nconst gridLayerProto = L.extend({}, L.GridLayer.prototype);\n\nL.GridLayer.include({\n\n    /**\n     * Redraw L.TileLayer bounds after the map is\n     * moved by just calling `map.setBearing(theta)`\n     * \n     * @listens L.Map~rotate\n     */\n    getEvents: function() {\n        var events = gridLayerProto.getEvents.apply(this, arguments);\n        if (this._map._rotate && !this.options.updateWhenIdle) {\n            if (!this._onRotate) {\n                this._onRotate = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);\n            }\n            events.rotate = this._onRotate;\n        }\n        return events;\n    },\n\n    _getTiledPixelBounds: function(center) {\n        if (!this._map._rotate) {\n            return gridLayerProto._getTiledPixelBounds.apply(this, arguments);\n        }\n\n        return this._map._getNewPixelBounds(center, this._tileZoom);\n    },\n\n});\n","/**\n * @external L.Renderer\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/vector/Renderer.js\n */\n\nconst rendererProto = L.extend({}, L.Renderer.prototype);\n\nL.Renderer.include({\n\n    /**\n     * Redraw L.Canvas and L.SVG renderer bounds after the\n     * map is moved by just calling `map.setBearing(theta)`\n     * \n     * @listens L.Map~rotate\n     */\n    getEvents: function() {\n        return L.extend(rendererProto.getEvents.apply(this, arguments), { rotate: this._update });\n    },\n\n    /**\n     * Fix for `map.flyTo()` when `false === map.options.zoomAnimation`\n     * \n     * @see https://github.com/Leaflet/Leaflet/pull/8794\n     */\n    onAdd: function() {\n        rendererProto.onAdd.apply(this, arguments);\n        if (L.version <= \"1.9.3\") {\n            // always keep transform-origin as 0 0\n            this._container.classList.add('leaflet-zoom-animated');\n        }\n    },\n\n    /**\n     * @FIXME layer drifts on `map.setZoom()` (eg. zoom during animation)\n     * \n     * the main cause seems to be related to `this._updateTransform(path._center, path._zoom))`\n     * and `this._topLeft = this._map.layerPointToLatLng(this._bounds.min);`\n     * \n     * @example\n     *   map.setZoom(2);\n     *   path._renderer._update();\n     *   path._renderer._updateTransform(path._renderer._center, path._renderer._zoom);\n     * \n     * @see https://github.com/Leaflet/Leaflet/pull/8794\n     * @see https://github.com/Leaflet/Leaflet/pull/8103\n     * @see https://github.com/Leaflet/Leaflet/issues/7466\n     * \n     * @TODO rechek this changes from leaflet@v1.9.3\n     * \n     * @see https://github.com/Leaflet/Leaflet/compare/v1.7.0...v1.9.3\n     */\n    _updateTransform: function(center, zoom) {\n        if (!this._map._rotate) {\n            return rendererProto._updateTransform.apply(this, arguments);\n        }\n        /**\n         * @FIXME see path._renderer._reset();\n         */\n        var scale = this._map.getZoomScale(zoom, this._zoom),\n            offset = this._map._latLngToNewLayerPoint(this._topLeft, zoom, center);\n\n        L.DomUtil.setTransform(this._container, offset, scale);\n        \n    },\n\n    // getEvents() {\n    //     const events = {\n    //         viewreset: this._reset,\n    //         zoom: this._onZoom,\n    //         moveend: this._update,\n    //         zoomend: this._onZoomEnd\n    //     };\n    //     if (this._zoomAnimated) {\n    //         events.zoomanim = this._onAnimZoom;\n    //     }\n    //     return events;\n    // },\n\n    // _onAnimZoom(ev) {\n    //     this._updateTransform(ev.center, ev.zoom);\n    // },\n\n\t// _onZoom() {\n    //     this._updateTransform(this._map.getCenter(), this._map.getZoom());\n\t// },\n\n    // _onZoomEnd() {\n    //     for (const id in this._layers) {\n    //         this._layers[id]._project();\n    //     }\n    // },\n\n    // _reset() {\n    //     this._update();\n    //     this._updateTransform(this._center, this._zoom);\n\n    //     for (const id in this._layers) {\n    //         this._layers[id]._reset();\n    //     }\n    // },\n\n    // _updatePaths() {\n    //     for (const id in this._layers) {\n    //         this._layers[id]._update();\n    //     }\n    // },\n\n    _update: function() {\n        if (!this._map._rotate) {\n            return rendererProto._update.apply(this, arguments);\n        }\n        // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n        // Subclasses are responsible of firing the 'update' event.\n        this._bounds = this._map._getPaddedPixelBounds(this.options.padding);\n        this._topLeft = this._map.layerPointToLatLng(this._bounds.min);\n        this._center = this._map.getCenter();\n        this._zoom = this._map.getZoom();\n    },\n\n});\n","/**\n * @external L.Map\n * \n * @see https://github.com/Leaflet/Leaflet/blob/v1.9.3/src/map/Map.js\n */\n\nconst mapProto = L.extend({}, L.Map.prototype);\n\nL.Map.mergeOptions({ rotate: false, bearing: 0, });\n\nL.Map.include({\n\n    /**\n     * @param {(HTMLElement|String)} id html selector\n     * @param {Object} [options={}] leaflet map options\n     */\n    initialize: function(id, options) {\n        if (options.rotate) {\n            this._rotate = true;\n            this._bearing = 0;\n        }\n        mapProto.initialize.apply(this, arguments);\n        if(this.options.rotate){\n          this.setBearing(this.options.bearing);\n        }\n    },\n\n    /**\n     * Given a pixel coordinate relative to the map container,\n     * returns the corresponding pixel coordinate relative to\n     * the [origin pixel](#map-getpixelorigin).\n     * \n     * @param {L.Point} point pixel screen coordinates\n     * @returns {L.Point} transformed pixel point\n     */\n    containerPointToLayerPoint: function(point) {\n        if (!this._rotate) {\n            return mapProto.containerPointToLayerPoint.apply(this, arguments);\n        }\n        return L.point(point)\n            .subtract(this._getMapPanePos())\n            .rotateFrom(-this._bearing, this._getRotatePanePos())\n            .subtract(this._getRotatePanePos());\n    },\n\n    /**\n     * Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n     * returns the corresponding pixel coordinate relative to the map container.\n     * \n     * @param {L.Point} point pixel screen coordinates\n     * @returns {L.Point} transformed pixel point\n     */\n    layerPointToContainerPoint: function(point) {\n        if (!this._rotate) {\n            return mapProto.layerPointToContainerPoint.apply(this, arguments);\n        }\n        return L.point(point)\n            .add(this._getRotatePanePos())\n            .rotateFrom(this._bearing, this._getRotatePanePos())\n            .add(this._getMapPanePos());\n    },\n\n    /**\n     * Converts a coordinate from the rotated pane reference system\n     * to the reference system of the not rotated map pane.\n     * \n     * (rotatePane) --> (mapPane)\n     * (rotatePane) --> (norotatePane)\n     * \n     * @param {L.Point} point pixel screen coordinates\n     * @returns {L.Point}\n     * \n     * @since leaflet-rotate (v0.1)\n     */\n    rotatedPointToMapPanePoint: function(point) {\n        return L.point(point)\n            .rotate(this._bearing)\n            ._add(this._getRotatePanePos());\n    },\n\n    /**\n     * Converts a coordinate from the not rotated map pane reference system\n     * to the reference system of the rotated pane.\n     * \n     * (mapPane) --> (rotatePane)\n     * (norotatePane) --> (rotatePane)\n     * \n     * @param {L.Point} point pixel screen coordinates\n     * \n     * @since leaflet-rotate (v0.1)\n     */\n    mapPanePointToRotatedPoint: function(point) {\n        return L.point(point)\n            ._subtract(this._getRotatePanePos())\n            .rotate(-this._bearing);\n    },\n\n    // latLngToLayerPoint: function (latlng) {\n    //     var projectedPoint = this.project(L.latLng(latlng))._round();\n    //     return projectedPoint._subtract(this.getPixelOrigin());\n    // },\n\n    // latLngToContainerPoint: function (latlng) {\n\t// \treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n\t// },\n\n    /**\n     * Given latlng bounds, returns the bounds in projected pixel\n     * relative to the map container.\n     * \n     * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/map/Map.js#L1114-L1135\n     * \n     * @param {L.LatLngBounds} bounds \n     * @returns {L.Bounds}\n     * \n     * @since leaflet-rotate (v0.2)\n     */\n    mapBoundsToContainerBounds: function (bounds) {\n        if (!this._rotate && mapProto.mapBoundsToContainerBounds) {\n            return mapProto.mapBoundsToContainerBounds.apply(this, arguments);\n        }\n\n        // const nw = this.latLngToContainerPoint(bounds.getNorthWest()),\n        //       ne = this.latLngToContainerPoint(bounds.getNorthEast()),\n        //       sw = this.latLngToContainerPoint(bounds.getSouthWest()),\n        //       se = this.latLngToContainerPoint(bounds.getSouthEast());\n\n        // same as `this.latLngToContainerPoint(latlng)` but with floating point precision\n        const origin = this.getPixelOrigin();\n        const nw = this.layerPointToContainerPoint(this.project(bounds.getNorthWest())._subtract(origin)),\n              ne = this.layerPointToContainerPoint(this.project(bounds.getNorthEast())._subtract(origin)),\n              sw = this.layerPointToContainerPoint(this.project(bounds.getSouthWest())._subtract(origin)),\n              se = this.layerPointToContainerPoint(this.project(bounds.getSouthEast())._subtract(origin));\n\n        return L.bounds([\n            L.point(Math.min(nw.x, ne.x, se.x, sw.x), Math.min(nw.y, ne.y, se.y, sw.y)), // [ minX, minY ]\n            L.point(Math.max(nw.x, ne.x, se.x, sw.x), Math.max(nw.y, ne.y, se.y, sw.y))  // [ maxX, maxY ]\n        ]);\n    },\n\n    /**\n     * Returns geographical bounds visible in the current map view\n     * \n     * @TODO find out  if map bounds calculated by `L.Map::getBounds()`\n     *       function should match the `rotatePane` or `norotatePane` bounds\n     * \n     * @see https://github.com/fnicollet/Leaflet/issues/7\n     * \n     * @returns {L.LatLngBounds}\n     */\n    getBounds: function() {\n        if (!this._rotate) {\n            return mapProto.getBounds.apply(this, arguments);\n        }\n\n        // SEE: https://github.com/fnicollet/Leaflet/pull/22\n        //\n        // var bounds = this.getPixelBounds(),\n        // sw = this.unproject(bounds.getBottomLeft()),\n        // ne = this.unproject(bounds.getTopRight());\n        // return new LatLngBounds(sw, ne);\n        //\n\n        // LatLngBounds' constructor automatically\n        // extends the bounds to fit the passed points\n        var size = this.getSize();\n        return new L.LatLngBounds([\n            this.containerPointToLatLng([0, 0]),           // topleft\n            this.containerPointToLatLng([size.x, 0]),      // topright \n            this.containerPointToLatLng([size.x, size.y]), // bottomright\n            this.containerPointToLatLng([0, size.y]),      // bottomleft\n        ]);\n    },\n\n    /**\n     * Returns the bounds of the current map view in projected pixel\n     * coordinates (sometimes useful in layer and overlay implementations).\n     * \n     * @TODO find out if map bounds calculated by `L.Map::getPixelBounds()`\n     *       function should match the `rotatePane` or `norotatePane` bounds\n     *\n     * @see https://github.com/fnicollet/Leaflet/issues/7\n     * \n     * @returns {L.Bounds}\n     */\n    // getPixelBounds(center, zoom) {\n    //     // const topLeftPoint = map.containerPointToLayerPoint(this._getTopLeftPoint());\n    //     const topLeftPoint = this._getTopLeftPoint(center, zoom);\n    //       return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    // },\n\n    /**\n     * Change map rotation\n     * \n     * @param {number} theta map degrees\n     * \n     * @since leaflet-rotate (v0.1)\n     */\n    setBearing: function(theta) {\n        if (!L.Browser.any3d || !this._rotate) { return; }\n\n        var bearing = L.Util.wrapNum(theta, [0, 360]) * L.DomUtil.DEG_TO_RAD,\n            center = this._getPixelCenter(),\n            oldPos = this._getRotatePanePos().rotateFrom(-this._bearing, center),\n            newPos = oldPos.rotateFrom(bearing, center);\n\n        // CSS transform\n        L.DomUtil.setPosition(this._rotatePane, oldPos, bearing, center);\n\n        this._pivot = center;\n        this._bearing = bearing;\n        this._rotatePanePos = newPos;\n\n        this.fire('rotate');\n    },\n\n    /**\n     * Get current map rotation\n     * \n     * @returns {number} theta map degrees\n     * \n     * @since leaflet-rotate (v0.1)\n     */\n    getBearing: function() {\n        return this._bearing * L.DomUtil.RAD_TO_DEG;\n    },\n\n    /**\n     * Creates a new [map pane](#map-pane) with the given name if it doesn't\n     * exist already, then returns it. The pane is created as a child of\n     * `container`, or as a child of the main map pane if not set.\n     * \n     * @param {String} name leaflet pane\n     * @param {HTMLElement} [container] parent element\n     * @returns {HTMLElement} pane container\n     */\n    // createPane: function(name, container) {\n    //     if (!this._rotate || name == 'mapPane') {\n    //         return mapProto.createPane.apply(this, arguments);\n    //     }\n    //     // init \"rotatePane\"\n    //     if (!this._rotatePane) {\n    //         // this._pivot = this.getSize().divideBy(2);\n    //         this._rotatePane = mapProto.createPane.call(this, 'rotatePane', this._mapPane);\n    //         L.DomUtil.setPosition(this._rotatePane, new L.Point(0, 0), this._bearing, this._pivot);\n    //     }\n    //     return mapProto.createPane.call(this, name, container || this._rotatePane);\n    // },\n\n    /**\n     * Panes are DOM elements used to control the ordering of layers on\n     * the map. You can access panes with [`map.getPane`](#map-getpane)\n     * or [`map.getPanes`](#map-getpanes) methods. New panes can be created\n     * with the [`map.createPane`](#map-createpane) method.\n     * \n     * Every map has the following default panes that differ only in zIndex:\n     * \n     * - mapPane     [HTMLElement = 'auto'] - Pane that contains all other map panes\n     * - tilePane    [HTMLElement = 2]      - Pane for tile layers\n     * - overlayPane [HTMLElement = 4]      - Pane for overlays like polylines and polygons\n     * - shadowPane  [HTMLElement = 5]      - Pane for overlay shadows (e.g. marker shadows)\n     * - markerPane  [HTMLElement = 6]      - Pane for marker icons\n     * - tooltipPane [HTMLElement = 650]    - Pane for tooltips.\n     * - popupPane   [HTMLElement = 700]    - Pane for popups.\n     */\n    _initPanes: function() {\n        var panes = this._panes = {};\n        this._paneRenderers = {};\n\n        this._mapPane = this.createPane('mapPane', this._container);\n        L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\n\n        if (this._rotate) {\n            this._rotatePane = this.createPane('rotatePane', this._mapPane);\n            this._norotatePane = this.createPane('norotatePane', this._mapPane);\n            // rotatePane\n            this.createPane('tilePane', this._rotatePane);\n            this.createPane('overlayPane', this._rotatePane);\n            // norotatePane\n            this.createPane('shadowPane', this._norotatePane);\n            this.createPane('markerPane', this._norotatePane);\n            this.createPane('tooltipPane', this._norotatePane);\n            this.createPane('popupPane', this._norotatePane);\n        } else {\n            this.createPane('tilePane');\n            this.createPane('overlayPane');\n            this.createPane('shadowPane');\n            this.createPane('markerPane');\n            this.createPane('tooltipPane');\n            this.createPane('popupPane');\n        }\n\n        if (!this.options.markerZoomAnimation) {\n            L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');\n            L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');\n        }\n    },\n\n    /**\n     * Pans the map the minimum amount to make the `latlng` visible. Use\n     * padding options to fit the display to more restricted bounds.\n     * If `latlng` is already within the (optionally padded) display bounds,\n     * the map will not be panned.\n     * \n     * @see https://github.com/Raruto/leaflet-rotate/issues/18\n     * \n     * @param {L.LatLng} latlng coordinates\n     * @param {Object} [options={}] padding options\n     * \n     * @returns {L.Map} current map instance\n     */\n    panInside(latlng, options) {\n        if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1) {\n            return mapProto.panInside.apply(this, arguments);\n        }\n\n        options = options || {};\n\n        const paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\n            paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\n            /** @TODO use mapProto.panInside */\n            // pixelPoint = this.project(latlng),\n            // pixelBounds = this.getPixelBounds(),\n            // pixelCenter = this.project(this.getCenter()),\n            rect = this._container.getBoundingClientRect(),\n            pixelPoint = this.latLngToContainerPoint(latlng),\n            pixelBounds = L.bounds([ L.point(rect), L.point(rect).add(this.getSize()) ]),\n            pixelCenter = pixelBounds.getCenter(),\n            //\n            paddedBounds = L.bounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\n            paddedSize = paddedBounds.getSize();\n        \n        if (!paddedBounds.contains(pixelPoint)) {\n            this._enforcingBounds = true;\n            const centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\n            const offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\n            pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\n            pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\n            /** @TODO use mapProto.panInside */\n            // this.panTo(this.unproject(pixelCenter), options);\n            this.panTo(this.containerPointToLatLng(pixelCenter), options);\n            //\n            this._enforcingBounds = false;\n        }\n        return this;\n    },\n\n    /**\n     * Pans the map to the closest view that would lie inside the given bounds\n     * (if it's not already), controlling the animation using the options specific,\n     * if any.\n     * \n     * @TODO check if map bounds calculated by `L.Map::panInsideBounds()`\n     *       function should match the `rotatePane` or `norotatePane` bounds\n     *\n     * @see https://github.com/fnicollet/Leaflet/issues/7\n     * \n     * @param {L.LatLngBounds} bounds coordinates\n     * @param {Object} [options] pan options\n     * @returns {L.Map} current map instance\n     */\n    // panInsideBounds: function (bounds, options) {\n    //     this._enforcingBounds = true;\n    //     var center = this.getCenter(),\n    //         newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));\n    //\n    //     if (!center.equals(newCenter)) {\n    //         this.panTo(newCenter, options);\n    //     }\n    //\n    //     this._enforcingBounds = false;\n    //     return this;\n    // },\n\n    // adjust center for view to get inside bounds\n    // _limitCenter(center, zoom, bounds) {\n    //\n    //     if (!bounds) { return center; }\n    //\n    //     const centerPoint = this.project(center, zoom),\n    //         viewHalf = this.getSize().divideBy(2),\n    //         viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n    //         offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n    //\n    //     // If offset is less than a pixel, ignore.\n    //     // This prevents unstable projections from getting into\n    //     // an infinite loop of tiny offsets.\n    //     if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\n    //             return center;\n    //     }\n    //\n    //     return this.unproject(centerPoint.add(offset), zoom);\n    // },\n\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    // flyToBounds(bounds, options) {\n    //     const target = this._getBoundsCenterZoom(bounds, options);\n    //     return this.flyTo(target.center, target.zoom, options);\n    // },\n\n    // _getBoundsCenterZoom(bounds, options) {\n    //\n    //     options = options || {};\n    //     bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n    //\n    //     const paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\n    //           paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]);\n    //\n    //     let zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n    //\n    //     zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;\n    //\n    //     if (zoom === Infinity) {\n    //         return { center: bounds.getCenter(), zoom };\n    //     }\n    //\n    //     return { center, zoom };\n    //\n    // },\n\n    /**\n     * Returns the maximum zoom level on which the given bounds fit to the map\n     * view in its entirety. If `inside` (optional) is set to `true`, the method\n     * instead returns the minimum zoom level on which the map view fits into\n     * the given bounds in its entirety.\n     * \n     * @param {L.LatLngBounds} bounds\n     * @param {Boolean} [inside=false]\n     * @param {L.Point} [padding=[0,0]]\n     * \n     * @returns {Number} zoom level\n     */\n    getBoundsZoom(bounds, inside, padding) {\n        if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1) {\n            return mapProto.getBoundsZoom.apply(this, arguments);\n        }\n\n        bounds = L.latLngBounds(bounds);\n        padding = L.point(padding || [0, 0]);\n\n        let zoom = this.getZoom() || 0;\n        const min = this.getMinZoom(),\n                max = this.getMaxZoom(),\n                /** @TODO use mapProto.getBoundsZoom */\n                // nw = bounds.getNorthWest(),\n                // se = bounds.getSouthEast(),\n                // size = this.getSize().subtract(padding),\n                // boundsSize = L.bounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n                size = this.getSize().subtract(padding),\n                boundsSize = this.mapBoundsToContainerBounds(bounds).getSize(),\n                snap = this.options.zoomSnap,\n                scalex = size.x / boundsSize.x,\n                scaley = size.y / boundsSize.y,\n                scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n\n        zoom = this.getScaleZoom(scale, zoom);\n\n        if (snap) {\n            zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n            zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n        }\n\n        return Math.max(min, Math.min(max, zoom));\n    },\n\n    /**\n     * Layer point of the current center\n     * \n     * @returns {L.Point} layer center\n     */\n    // _getCenterLayerPoint: function () {\n    //    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    // },\n\n    /**\n     * Offset of the specified place to the current center in pixels\n     * \n     * @param {L.LatLng} latlng map coordinates\n     */\n    _getCenterOffset: function(latlng) {\n        var centerOffset = mapProto._getCenterOffset.apply(this, arguments);\n        if (this._rotate) {\n            centerOffset = centerOffset.rotate(this._bearing);\n        }\n        return centerOffset;\n    },\n\n    /**\n     * @since leaflet-rotate (v0.1)\n     */\n    _getRotatePanePos: function() {\n        return this._rotatePanePos || new L.Point(0, 0);\n        // return L.DomUtil.getPosition(this._rotatePane) || new L.Point(0, 0);\n    },\n\n    // _latLngToNewLayerPoint(latlng, zoom, center) {\n    //    const topLeft = this._getNewPixelOrigin(center, zoom);\n    //    return this.project(latlng, zoom)._subtract(topLeft);\n    //},\n\n    _getNewPixelOrigin: function(center, zoom) {\n        if (!this._rotate) {\n            return mapProto._getNewPixelOrigin.apply(this, arguments);\n        }\n        var viewHalf = this.getSize()._divideBy(2);\n        return this.project(center, zoom)\n            .rotate(this._bearing)\n            ._subtract(viewHalf)\n            ._add(this._getMapPanePos())\n            ._add(this._getRotatePanePos())\n            .rotate(-this._bearing)\n            ._round();\n    },\n\n    /**\n     * @since leaflet-rotate (v0.2)\n     * \n     * @see src\\layer\\tile\\GridLayer::_getTiledPixelBounds()\n     */\n    _getNewPixelBounds: function(center, zoom) {\n        center = center || this.getCenter();\n        zoom = zoom || this.getZoom();\n        if (!this._rotate && mapProto._getNewPixelBounds) {\n            return mapProto._getNewPixelBounds.apply(this, arguments);\n        }\n        var mapZoom = this._animatingZoom ? Math.max(this._animateToZoom, this.getZoom()) : this.getZoom(),\n            scale = this.getZoomScale(mapZoom, zoom),\n            pixelCenter = this.project(center, zoom).floor(),\n            size = this.getSize(),\n            halfSize = new L.Bounds([\n                this.containerPointToLayerPoint([0, 0]).floor(),\n                this.containerPointToLayerPoint([size.x, 0]).floor(),\n                this.containerPointToLayerPoint([0, size.y]).floor(),\n                this.containerPointToLayerPoint([size.x, size.y]).floor()\n            ]).getSize().divideBy(scale * 2);\n\n        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n\n    /**\n     * @since leaflet-rotate (v0.2)\n     * \n     * @return {L.Point} map pivot point (center)\n     */\n    _getPixelCenter: function() {\n        if (!this._rotate && mapProto._getPixelCenter) {\n            return mapProto._getPixelCenter.apply(this, arguments);\n        }\n        return this.getSize()._divideBy(2)._subtract(this._getMapPanePos());\n    },\n\n    /**\n     * @since leaflet-rotate (v0.2)\n     * \n     * @see src\\layer\\vector\\Renderer::_update()\n     */\n    _getPaddedPixelBounds: function(padding) {\n        if (!this._rotate && mapProto._getPaddedPixelBounds) {\n            return mapProto._getPaddedPixelBounds.apply(this, arguments);\n        }\n        var p = padding,\n            size = this.getSize(),\n            padMin = size.multiplyBy(-p),\n            padMax = size.multiplyBy(1 + p);\n            //min = this.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n        return new L.Bounds([\n            this.containerPointToLayerPoint([padMin.x, padMin.y]).floor(),\n            this.containerPointToLayerPoint([padMin.x, padMax.y]).floor(),\n            this.containerPointToLayerPoint([padMax.x, padMin.y]).floor(),\n            this.containerPointToLayerPoint([padMax.x, padMax.y]).floor()\n        ]);\n    },\n\n    _handleGeolocationResponse: function(pos) {\n        if (!this._container._leaflet_id) { return; }\n\n        var lat = pos.coords.latitude,\n            lng = pos.coords.longitude,\n            /** @TODO use mapProto._handleGeolocationResponse */\n            hdg = pos.coords.heading,\n            latlng = new L.LatLng(lat, lng),\n            bounds = latlng.toBounds(pos.coords.accuracy),\n            options = this._locateOptions;\n\n        if (options.setView) {\n            var zoom = this.getBoundsZoom(bounds);\n            this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n        }\n\n        var data = {\n            latlng: latlng,\n            bounds: bounds,\n            timestamp: pos.timestamp,\n            /** @TODO use mapProto._handleGeolocationResponse */\n            heading: hdg\n        };\n\n        for (var i in pos.coords) {\n            if (typeof pos.coords[i] === 'number') {\n                data[i] = pos.coords[i];\n            }\n        }\n\n        // @event locationfound: LocationEvent\n        // Fired when geolocation (using the [`locate`](#map-locate) method)\n        // went successfully.\n        this.fire('locationfound', data);\n    },\n\n    /**\n     * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/geo/LatLngBounds.js#L253-L264\n     * \n     * @param {L.Bounds} points \n     * @returns {L.Bounds}\n     */\n    // toCircumscribedBounds(points) {\n    //     var minX = points.reduce(function (pv, v) { return Math.min(pv, v.x); }, points[0].x),\n    //         maxX = points.reduce(function (pv, v) { return Math.max(pv, v.x); }, points[0].x),\n    //         minY = points.reduce(function (pv, v) { return Math.min(pv, v.y); }, points[0].y),\n    //         maxY = points.reduce(function (pv, v) { return Math.max(pv, v.y); }, points[0].y);\n    //\n    //     return L.bounds(L.point(minX, minY), L.point(maxX, maxY));\n    // },\n\n});\n","/**\n * Triggers `invalidateResize` when the map's DOM container mutates.\n * \n * @typedef L.Map.ContainerMutation\n */\n\n/**\n * @TODO check again this file after leaflet v1.9.3 (eg. L.Browser.mutation).\n * Mutation Observer support will likely be added by default in next releases.\n */\n\nL.Map.mergeOptions({\n\n    /**\n     * Whether the map uses mutation observers to\n     * detect changes in its container and trigger\n     * `invalidateSize`. Disabled by default due to\n     * support not being available in all web browsers.\n     *\n     * @type {Boolean}\n     * \n     * @see https://developer.mozilla.org/docs/Web/API/MutationObserver\n     */\n    trackContainerMutation: false\n\n});\n\nL.Map.ContainerMutation = L.Handler.extend({\n\n    addHooks: function() {\n        // if (!L.Browser.mutation) { return; }\n        if (!this._observer) {\n            this._observer = new MutationObserver(L.Util.bind(this._map.invalidateSize, this._map));\n        }\n        this._observer.observe(this._map.getContainer(), {\n            childList: false,\n            attributes: true,\n            characterData: false,\n            subtree: false,\n            attributeFilter: ['style']\n        });\n    },\n\n    removeHooks: function() {\n        // if (!L.Browser.mutation) { return; }\n        this._observer.disconnect();\n    },\n\n});\n\n/**\n * Add Container mutation handler to L.Map (disabled unless `trackContainerMutation` is set).\n * \n * @property {L.Map.ContainerMutation} trackContainerMutation\n */\nL.Map.addInitHook('addHandler', 'trackContainerMutation', L.Map.ContainerMutation);\n","/**\n * A tri-state control for map rotation, states are:\n *\n * - Locked (default)\n * - Unlocked (user can pinch-rotate)\n * - Follow (rotation follows device orientation, if available)\n *\n * @typedef L.Control.Rotate\n */\n\nL.Control.Rotate = L.Control.extend({\n    options: {\n        position: \"topleft\",\n        closeOnZeroBearing: true,\n    },\n\n    onAdd: function (map) {\n        var container = (this._container = L.DomUtil.create(\n            \"div\",\n            \"leaflet-control-rotate leaflet-bar\"\n        ));\n\n        // this.button = L.Control.Zoom.prototype._createButton.call(this, 'R', 'leaflet-control-rotate', 'leaflet-control-rotate', container, this._toggleLock);\n\n        var arrow = (this._arrow = L.DomUtil.create(\n            \"span\",\n            \"leaflet-control-rotate-arrow\"\n        ));\n\n        arrow.style.backgroundImage = `url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E\")`;\n        arrow.style.cursor = \"grab\";\n        arrow.style.display = \"block\";\n        arrow.style.width = \"100%\";\n        arrow.style.height = \"100%\";\n        arrow.style.backgroundRepeat = \"no-repeat\";\n        arrow.style.backgroundPosition = \"50%\";\n\n        // Copy-pasted from L.Control.Zoom\n        var link = (this._link = L.DomUtil.create(\n            \"a\",\n            \"leaflet-control-rotate-toggle\",\n            container\n        ));\n        link.appendChild(arrow);\n        link.href = \"#\";\n        link.title = \"Rotate map\";\n\n        L.DomEvent.on(link, \"dblclick\", L.DomEvent.stopPropagation)\n            .on(link, \"mousedown\", this._handleMouseDown, this)\n            .on(link, \"click\", L.DomEvent.stop)\n            .on(link, \"click\", this._cycleState, this)\n            .on(link, \"click\", this._refocusOnMap, this);\n\n        if (!L.Browser.any3d) {\n            L.DomUtil.addClass(link, \"leaflet-disabled\");\n        }\n\n        this._restyle();\n\n        map.on(\"rotate\", this._restyle, this);\n\n        // State flag\n        this._follow = false;\n        this._canFollow = false;\n\n        if (this.options.closeOnZeroBearing && map.getBearing() === 0) {\n            container.style.display = \"none\";\n        }\n\n        return container;\n    },\n\n    onRemove: function (map) {\n        map.off(\"rotate\", this._restyle, this);\n    },\n\n    _handleMouseDown: function (e) {\n        L.DomEvent.stop(e);\n        this.dragging = true;\n        this.dragstartX = e.pageX;\n        this.dragstartY = e.pageY;\n        L.DomEvent.on(document, \"mousemove\", this._handleMouseDrag, this).on(\n            document,\n            \"mouseup\",\n            this._handleMouseUp,\n            this\n        );\n    },\n\n    _handleMouseUp: function (e) {\n        L.DomEvent.stop(e);\n        this.dragging = false;\n\n        L.DomEvent.off(document, \"mousemove\", this._handleMouseDrag, this).off(\n            document,\n            \"mouseup\",\n            this._handleMouseUp,\n            this\n        );\n    },\n\n    _handleMouseDrag: function (e) {\n        if (!this.dragging) {\n            return;\n        }\n        var deltaX = e.clientX - this.dragstartX;\n        this._map.setBearing(deltaX);\n    },\n\n    _cycleState: function (ev) {\n        if (!this._map) {\n            return;\n        }\n\n        var map = this._map;\n\n        // // Touch mode\n        // if (!map.touchRotate.enabled() && !map.compassBearing.enabled()) {\n        //     map.touchRotate.enable();\n        // }\n\n        // Compass mode\n        // else if (!map.compassBearing.enabled()) {\n        //     map.touchRotate.disable();\n        //     (\n        //         DeviceOrientationEvent && DeviceOrientationEvent.requestPermission\n        //             ? DeviceOrientationEvent.requestPermission() // iOS compass\n        //             : Promise.resolve('granted')                 // others\n        //     ).then(state => \"granted\" === state && map.compassBearing.enable())\n        // }\n\n        // Locked mode\n        // else {\n        // map.compassBearing.disable();\n        map.setBearing(0);\n        // if (this.options.closeOnZeroBearing) {\n        //     map.touchRotate.enable();\n        // }\n        // }\n        this._restyle();\n    },\n\n    _restyle: function () {\n        if (!this._map.options.rotate) {\n            L.DomUtil.addClass(this._link, \"leaflet-disabled\");\n        } else {\n            var map = this._map;\n            var bearing = map.getBearing();\n\n            this._arrow.style.transform = \"rotate(\" + bearing + \"deg)\";\n\n            this._link.style.backgroundColor = null;\n\n            if (bearing && this.options.closeOnZeroBearing) {\n                this._container.style.display = \"block\";\n            }\n            if (0 === bearing && this.options.closeOnZeroBearing) {\n                this._container.style.display = \"none\";\n            }\n            // }\n        }\n    },\n});\n\nL.control.rotate = function (options) {\n    return new L.Control.Rotate(options);\n};\n\nL.Map.mergeOptions({\n    rotateControl: true,\n});\n\nL.Map.addInitHook(function () {\n    if (this.options.rotateControl) {\n        var options =\n            typeof this.options.rotateControl === \"object\"\n                ? this.options.rotateControl\n                : {};\n        this.rotateControl = L.control.rotate(options);\n        this.addControl(this.rotateControl);\n    }\n});\n"],"names":["domUtilProto","L","extend","DomUtil","setTransform","el","offset","scale","bearing","pivot","console","log","pos","Point","_round","apply","this","arguments","rotateFrom","style","TRANSFORM","x","y","DEG_TO_RAD","Math","PI","RAD_TO_DEG","Draggable","include","prototype","rotate","theta","sinTheta","sin","cosTheta","cos","cx","cy","divOverlayProto","DivOverlay","getEvents","_updatePosition","_map","_rotate","_zoomAnimated","anchor","_getAnchor","getPosition","_container","subtract","setPosition","rotatedPointToMapPanePoint","add","popupProto","Popup","_animateZoom","e","_adjustPan","options","autoPan","_panAnim","_inProgress","_autopanning","map","marginBottom","parseInt","getStyle","containerHeight","offsetHeight","containerWidth","_containerWidth","layerPos","_containerLeft","_containerBottom","_add","containerPos","_getMapPanePos","padding","point","autoPanPadding","paddingTL","autoPanPaddingTopLeft","paddingBR","autoPanPaddingBottomRight","size","getSize","dx","dy","keepInView","fire","panBy","tooltipProto","Tooltip","_latLngToNewLayerPoint","_latlng","zoom","center","_setPosition","latLngToLayerPoint","Icon","_setIconStyles","img","name","sizeOption","shadowAnchor","iconAnchor","divideBy","className","marginLeft","marginTop","width","height","markerProto","Marker","markerDragProto","mergeOptions","rotation","rotateWithView","undefined","MarkerDrag","_onDrag","marker","_marker","rotated_marker","shadow","_shadow","iconPos","_icon","mapPanePointToRotatedPoint","latlng","layerPointToLatLng","oldLatLng","_oldLatLng","setLatLng","_onDragEnd","update","_initInteraction","ret","dragging","enabled","Object","getPrototypeOf","disable","assign","bind","enable","_setPos","_bearing","_zIndex","zIndexOffset","_resetZIndex","setRotation","gridLayerProto","GridLayer","events","updateWhenIdle","_onRotate","Util","throttle","_onMoveEnd","updateInterval","_getTiledPixelBounds","_getNewPixelBounds","_tileZoom","rendererProto","Renderer","_update","onAdd","version","classList","_updateTransform","getZoomScale","_zoom","_topLeft","_bounds","_getPaddedPixelBounds","min","_center","getCenter","getZoom","mapProto","Map","initialize","id","setBearing","containerPointToLayerPoint","_getRotatePanePos","layerPointToContainerPoint","_subtract","mapBoundsToContainerBounds","bounds","origin","getPixelOrigin","nw","project","getNorthWest","ne","getNorthEast","sw","getSouthWest","se","getSouthEast","max","getBounds","LatLngBounds","containerPointToLatLng","Browser","any3d","wrapNum","_getPixelCenter","oldPos","newPos","_rotatePane","_pivot","_rotatePanePos","getBearing","_initPanes","panes","_panes","_paneRenderers","_mapPane","createPane","_norotatePane","markerZoomAnimation","addClass","markerPane","shadowPane","panInside","abs","toFixed","paddingTopLeft","paddingBottomRight","rect","getBoundingClientRect","pixelPoint","latLngToContainerPoint","pixelBounds","pixelCenter","paddedBounds","paddedSize","contains","_enforcingBounds","centerOffset","panTo","getBoundsZoom","inside","latLngBounds","getMinZoom","getMaxZoom","boundsSize","snap","zoomSnap","scalex","scaley","getScaleZoom","round","ceil","floor","_getCenterOffset","_getNewPixelOrigin","viewHalf","_divideBy","mapZoom","_animatingZoom","_animateToZoom","halfSize","Bounds","p","padMin","multiplyBy","padMax","_handleGeolocationResponse","_leaflet_id","lat","coords","latitude","lng","longitude","hdg","heading","LatLng","toBounds","accuracy","_locateOptions","setView","maxZoom","data","timestamp","i","trackContainerMutation","ContainerMutation","Handler","addHooks","_observer","MutationObserver","invalidateSize","observe","getContainer","childList","attributes","characterData","subtree","attributeFilter","removeHooks","disconnect","addInitHook","Control","Rotate","position","closeOnZeroBearing","container","create","arrow","_arrow","backgroundImage","cursor","display","backgroundRepeat","backgroundPosition","link","_link","appendChild","href","title","DomEvent","on","stopPropagation","_handleMouseDown","stop","_cycleState","_refocusOnMap","_restyle","_follow","_canFollow","onRemove","off","dragstartX","pageX","dragstartY","pageY","document","_handleMouseDrag","_handleMouseUp","deltaX","clientX","ev","transform","backgroundColor","control","rotateControl","addControl"],"mappings":"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"}